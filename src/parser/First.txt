program={TK_FUNID, TK_MAIN}
mainFunction={TK_MAIN}
otherFunctions={TK_FUNID, EPSILON}
function={TK_FUNID}
input_par={TK_INPUT}
output_par={TK_OUTPUT, EPSILON}
parameter_list={TK_INT, TK_REAL, TK_RECORD, TK_UNION, TK_RUID}
datatype={TK_INT, TK_REAL, TK_RECORD, TK_UNION, TK_RUID}
primitiveDatatype={TK_INT, TK_REAL}
constructedDatatype={TK_RECORD, TK_UNION, TK_RUID}
remaining_list={TK_COMMA, EPSILON}
stmts={EPSILON, TK_RECORD, TK_UNION, TK_TYPE, TK_ID, TK_WHILE, TK_IF, TK_READ, Tk_WRITE, TK_SQL, TK_CALL, TK_DEFINETYPE, TK_RETURN} 
typeDefinitions={EPSILON, TK_DEFINETYPE,TK_RECORD, TK_UNION}
typeDefinition={TK_RECORD, TK_UNION}
fieldDefinitions={TK_TYPE}
fieldDefinition={TK_TYPE}
moreFields={EPSILONN,TK_TYPE}
declarations={EPSILON,TK_TYPE}
declaration={TK_TYPE}
global_or_not={TK_COLON,EPSILON}
otherStmts={EPSILON,TK_ID,TK_WHILE,TK_IF,TK_READ,TK_WRITE,TK_SQL,TK_CALL}
stmt={TK_ID,TK_WHILE,TK_IF,TK_READ,TK_WRITE,TK_SQL,TK_CALL}
assignmentStmt={TK_ID}
singleOrRecId={TK_ID}
singleOrRecIdLF={TK_DOT,EPSILON}
funCallStmt={TK_SQL,TK_CALL}
outputParameters={TK_SQL,EPSILON}
inputParameters={TK_SQL}
iterativeStmt={TK_WHILE}
conditionalStmt={TK_IF}
conditionalStmtLF={EPSILON,TK_ELSE}
ioStmt={TK_READ,TK_WRITE}
arithmeticExpression={TK_OP,TK_NUM,TK_RNUM,TK_ID}
plusMinusLF={TK_ADD,TK_MINUS}
multDivExpr={ TK_OP,TK_ID,TK_NUM,TK_RNUM}
multDivLR={EPSILON,TK_MUL,TK_DIV}
multDivLF={TK_MUL,TK_DIV}
outerMost={TK_OP,TK_ID,TK_NUM,TK_RNUM}
booleanExpression={TK_OP, TK_ID, TK_NUM, TK_RNUM, TK_NOT}
var={TK_ID,TK_NUM, TK_RNUM}
logicalOp={TK_AND,TK_OR}
relationalOp={TK_LT, TK_LE, TK_EQ, TK_GT, TK_GE,TK_NE}
returnStmt={TK_RETURN}
optionalReturn={TK_SQL,EPSILON}
idList={TK_ID}
more_ids={EPSILON,TK_COMMA}
definetypestmt={TK_DEFINETYPE}
A={TK_RECORD,TK_UNION}